//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由jason生成。
//     运行时版本:4.0.30319.18063
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System.Collections.Generic;
using UnityEngine;
using ProtoBuf;

namespace NetWorklib
{
	public class CPacketQueueUnit
	{
		public System.Object m_writeLock;
		public System.Object m_readLock;
		public Queue<DataUnit> m_writeQueue;
		public Queue<DataUnit> m_readQueue;
		public CPacketQueueUnit(){
			m_writeLock = new object ();
			m_readLock = new object ();
			m_writeQueue = new Queue<DataUnit> ();
			m_readQueue = new Queue<DataUnit> ();
		}
	}

	/// <summary>
	/// P/ 数据包管理，支持多线程
	/// </summary>
	public class PacketManager
	{
		static private PacketManager __packetManeger =  null ;

		static public PacketManager Instence{
			get{ 
				if(__packetManeger == null)
					__packetManeger = new PacketManager();

				return __packetManeger;
			}
		}


		public PacketManager()
		{
			__queueUnitMap = new Dictionary<int, CPacketQueueUnit> ();
			__process_map = new Dictionary<ushort, PacketProcessStruct> ();
		}

		/// <summary>
		/// 网络线程调用，把一个数据包放到可读数据包队列中.
		/// </summary>
		/// <param name="inputPacket">Input packet.</param>
		public void AddInputData(DataUnit inputData){
			CPacketQueueUnit queueUnit = null;
			if (__queueUnitMap.TryGetValue (inputData.m_nChannelID, out queueUnit)) {
				lock (queueUnit.m_readLock) {
					queueUnit.m_readQueue.Enqueue (inputData);
				}
			} else {
				queueUnit = new CPacketQueueUnit();
				queueUnit.m_readQueue.Enqueue(inputData);
				__queueUnitMap.Add(inputData.m_nChannelID,queueUnit);
			}
		}

		/// <summary>
		/// 把一个数据包放到可写队列中
		/// </summary>
		/// <param name="outputPacket">Output packet.</param>
		public void AddOutputData(DataUnit outputData){
			CPacketQueueUnit queueUnit = null;
			if (__queueUnitMap.TryGetValue (outputData.m_nChannelID,out queueUnit)) {
				lock(queueUnit.m_writeLock){
					queueUnit.m_writeQueue.Enqueue(outputData);
				}
			}
		}
	
		/// <summary>
		/// 处理数据包，回调上层方法，执行对应命令动作
		/// UI线程需要定时调用这个函数以便处理收到的数据
		/// </summary>
		public void  DoInputPackage(int nChannelID)
		{
			Queue<DataUnit> queue = null;
			CPacketQueueUnit queueUnit = null;
			if (__queueUnitMap.TryGetValue (nChannelID,out queueUnit)) {
				if(queueUnit.m_readQueue.Count > 0)
				{
					lock(queueUnit.m_readLock){
						queue = queueUnit.m_readQueue;
						queueUnit.m_readQueue = new Queue<DataUnit>();
					}
				}
			}	
			
			if(queue != null)
			{
				DataUnit dataUnit = null;
				while(queue.Count > 0)
				{
					dataUnit = queue.Dequeue();
					if(__process_map.ContainsKey(dataUnit.m_nCmd))
					{
						if(__process_map[dataUnit.m_nCmd].DoProcess != null)
							__process_map[dataUnit.m_nCmd].DoProcess(dataUnit);
					}
					else{
						Debug.LogError(" dataunit cmd not exist! cmd:"+dataUnit.m_nCmd);
					}
					//dataUnit = null;
				}
			}
		}

		/// <summary>
		/// 根据 ID 取出要发送的消息队列.
		/// </summary>
		/// <returns>The output packet queue.</returns>
		/// <param name="nChannelID">N channel I.</param>
		public Queue<DataUnit> GetOutputPacketQueue(int nChannelID){

			Queue<DataUnit> queue = null;
			CPacketQueueUnit queueUnit = null;
			if (__queueUnitMap.TryGetValue (nChannelID,out queueUnit)) {
				if(queueUnit.m_writeQueue.Count > 0)
				{
					lock(queueUnit.m_writeLock){
						queue = queueUnit.m_writeQueue;
						queueUnit.m_writeQueue = new Queue<DataUnit>();
					}
				}
			}		

			return queue ;
		}

		/// <summary>
		/// 注册数据包处理器，由用户自己注册
		/// </summary>
		/// <param name="nCmd">数据包命令.</param>
		/// <param name="process">处理器结构体.</param>
		public void RegistPacketProcess(ushort nCmd,PacketProcessStruct process)
		{
			__process_map [nCmd] = process;
		}

		/// <summary>
		/// 注册数据包解析器
		/// </summary>
		/// <param name="nCmd">数据包命令d.</param>
		/// <param name="parserProcess">数据包解析器.</param>
		public void RegistParserProcess(ushort nCmd,OnParserPacket parserProcess)
		{
			if (!__process_map.ContainsKey (nCmd)) {
				__process_map.Add(nCmd, new PacketProcessStruct( parserProcess,null));
			} else {
				PacketProcessStruct temp = __process_map[nCmd];
				temp.ParserProcess = parserProcess;
				__process_map [nCmd] = temp;
			}
		}

		/// <summary>
		/// 注册数据包处理器
		/// </summary>
		/// <param name="nCmd">数据包命令.</param>
		/// <param name="processPacket">数据包处理器.</param>
		public void RegistDoProcess(ushort nCmd,OnProcessPacket processPacket)
		{
			if (!__process_map.ContainsKey (nCmd)) {
				__process_map.Add(nCmd, new PacketProcessStruct( null,processPacket));
			} else {
				PacketProcessStruct temp = __process_map[nCmd];
				temp.DoProcess = processPacket;
				__process_map[nCmd] = temp;
			}
		}


		public void UnRegistPacketProcess(ushort nCmd)
		{
			if(__process_map.ContainsKey(nCmd))
				__process_map.Remove (nCmd);
		}
		
		public void UnRegistParserProcess(ushort nCmd)
		{
			if (__process_map.ContainsKey (nCmd)) {
				PacketProcessStruct temp = __process_map[nCmd];
				temp.ParserProcess = null;
				__process_map[nCmd] = temp;
			}
		}
		
		public void UnRedistDoProcess(ushort nCmd)
		{
			if (__process_map.ContainsKey (nCmd)) {
				PacketProcessStruct temp = __process_map[nCmd];
				temp.DoProcess = null;
				__process_map[nCmd] = temp;
			}
		}


		/// <summary>
		///  使用用户注册的解析器解析出是举报并且将解析出来的数据包放到可读数据包队列中
		/// </summary>
		/// <returns>The packet process.</returns>
		/// <param name="package">Package.</param>
		public int ParserPacketProcess(CCNetworkPacket package,SocketHandler socket)
		{
			ushort nCmd = package.ReadCmd ();
		
			if (__process_map.ContainsKey (nCmd)) {
				PacketProcessStruct pstu = __process_map [nCmd];
				if( pstu.ParserProcess != null)
				{
					DataUnit dataUnit = pstu.ParserProcess (package);
					
					if (dataUnit != null) {
						dataUnit.m_nChannelID = socket.m_nHandleID;
						AddInputData (dataUnit);
						return 0;
					} else {
						/// 如果返回-1，底层会断开链接
						Debug.LogError(" cmd parser error ! cmd:" +nCmd);
						return -1;
					}
				}

			} 

			///没有注册解析器时打出日志方便查找问题
			Debug.LogError(" cmd process not exist ! cmd:" +nCmd);

			return 0;

		}
/**
		public CCNetworkPacket BuildPacketByDataUnit( DataUnit dataUnit)
		{
			if (dataUnit.m_oBodyUnit != null) {
				System.IO.MemoryStream mem = new System.IO.MemoryStream ();
				ProtoBuf.Serializer.Serialize(mem ,dataUnit.m_oBodyUnit);
				COutputPacket package = new COutputPacket();
				package.WriteCmd(dataUnit.m_nCmd);
				package.WriteCode(dataUnit.m_bCode);
				package.WriteVersion(dataUnit.m_bVS);
				package.WriteSeqNum(dataUnit.m_nSeq);
				package.WriteCmd(dataUnit.m_nCmd);
				package.WriteDst(dataUnit.m_nDest);
				package.WriteSrc(dataUnit.m_nSrc);

				package.WriteBody(mem.GetBuffer(),0,(ushort)mem.Length);
				package.End();

				return package;
			} else {
				COutputPacket package = new COutputPacket();
				package.WriteCmd(dataUnit.m_nCmd);
				package.WriteCode(dataUnit.m_bCode);
				package.WriteVersion(dataUnit.m_bVS);
				package.WriteSeqNum(dataUnit.m_nSeq);
				package.WriteCmd(dataUnit.m_nCmd);
				package.WriteDst(dataUnit.m_nDest);
				package.WriteSrc(dataUnit.m_nSrc);
				package.End();

				return package;
			}
		}
**/

		private Dictionary<int,CPacketQueueUnit > __queueUnitMap;

		private System.Collections.Generic.Dictionary<ushort,PacketProcessStruct> __process_map;
	}
}

